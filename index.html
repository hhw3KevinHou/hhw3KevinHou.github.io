<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-springDAO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/08/springDAO/" class="article-date">
  <time datetime="2018-06-08T04:52:08.000Z" itemprop="datePublished">2018-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Maven/">Maven</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/springDAO/">Spring Data access</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-DAO"><a href="#Spring-DAO" class="headerlink" title="Spring-DAO"></a>Spring-DAO</h1><p>Spring-DAO is not stricto senso a spring module, but rather conventions that should dictate you to write DAO, and to write them well. As such, it does neither provide interfaces nor implementations nor templates to access your data. When writing a DAO, you should annotate them with @Repository so that exceptions linked to the underlying technology (JDBC, Hibernate, JPA, etc.) are consistently translated into the proper DataAccessException subclass.</p>
<p>As an example, suppose you’re now using Hibernate, and your service layer catches HibernateException in order to react to it. If you change to JPA, your DAOs interfaces should not change, and the service layer will still compile with blocks that catches HibernateException, but you will never enter these blocks as your DAOs are now throwing JPA PersistenceException. By using @Repository on your DAO, the exceptions linked to the underlying technology are translated to Spring DataAccessException; your service layer catches these exceptions and if you decide to change the persistence technology, the same Spring DataAccessExceptions will still be thrown as spring have translated native exceptions.</p>
<p>Note however that this has limited usage for the following reasons:</p>
<ol>
<li>Your should usually not catch persistence exceptions, as the provider may have rolled back the transaction (depending on the exact exception subtype), and thus you should not continue the execution with an alternative path.</li>
</ol>
<ol start="2">
<li>The hierarchy of exceptions is usually richer in your provider than what Spring provides, and there’s no definitive mapping from one provider to the other. Relying on this is hazardous. This is however a good idea to annotate your DAOs with @Repository, as the beans will be automatically added by the scan procedure. Further, Spring may add other useful features to the annotation.</li>
</ol>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring-JDBC"></a>Spring-JDBC</h1><p>Spring-JDBC provides the JdbcTemplate class, that removes plumbing code and helps you concentrate on the SQL query and parameters. You just need to configure it with a DataSource, and you can then write code like this:</p>
<pre><code>int nbRows = jdbcTemplate.queryForObject(&quot;select count(1) from person&quot;, Integer.class);

Person p = jdbcTemplate.queryForObject(&quot;select first, last from person where id=?&quot;, 
 rs -new Person(rs.getString(1), rs.getString(2)), 
 134561351656L);
</code></pre><p>Spring-JDBC also provides a JdbcDaoSupport, that you can extend to develop your DAO. It basically defines 2 properties: a DataSource and a JdbcTemplate that both can be used to implement the DAO methods. It also provides an exceptions translator from SQL exceptions to spring DataAccessExceptions.</p>
<p>If you plan to use plain jdbc, this is the module you will need to use.</p>
<h1 id="Spring-ORM"><a href="#Spring-ORM" class="headerlink" title="Spring-ORM"></a>Spring-ORM</h1><p>Spring-ORM is an umbrella module that covers many persistence technologies, namely JPA, JDO, Hibernate and iBatis. For each of these technologies, Spring provides integration classes so that each technology can be used following Spring principles of configuration, and smoothly integrates with Spring transaction management.</p>
<p>For each technology, the configuration basically consists in injecting a DataSource bean into some kind of SessionFactory or EntityManagerFactory etc. bean. For pure JDBC, there’s no need for such integration classes (apart from JdbcTemplate), as JDBC only relies on a DataSource.</p>
<p>If you plan to use an ORM like JPA or Hibernate, you will not need spring-jdbc, but only this module.</p>
<h1 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring-Data"></a>Spring-Data</h1><p>Spring-Data is an umbrella project that provides a common API to define how to access data (DAO + annotations) in a more generic way, covering both SQL and NOSQL data sources.</p>
<p>The initial idea is to provide a technology so that the developer writes the interface for a DAO (finder methods) and the entity classes in a technology-agnostic way and, based on configuration only (annotations on DAOs &amp; entities + spring configuration, be it xml- or java-based), decides the implementation technology, be it JPA (SQL) or redis, hadoop, etc. (NOSQL).</p>
<p>If you follow the naming conventions defined by spring for the finder method names, you don’t even need to provide the query strings corresponding to finder methods for the most simple cases. For other situations, you have to provide the query string inside annotations on the finder methods.</p>
<p>When the application context is loaded, spring provides proxies for the DAO interfaces, that contain all the boilerplate code related to the data access technology, and invokes the configured queries.</p>
<p>Spring-Data concentrates on non-SQL technologies, but still provides a module for JPA (the only SQL technology).</p>
<h3 id="Need-Hibernate…"><a href="#Need-Hibernate…" class="headerlink" title="Need  Hibernate…?"></a>Need  Hibernate…?</h3><p>You can use a core Spring module like Spring JDBC for directly working with MySQL (or any other RDBMS) but if you wish to use Spring Data JPA, you will need an underlying JPA implementation (since Spring Data JPA is a wrapper on top of JPA and not a JPA implementation in itself) like Hibernate or EclipseLink.</p>
<p>The structure is as follows:</p>
<pre><code>Spring Data JPA
   |
  JPA
   |
Hibernate
</code></pre><p>You need Hibernate as an JPA implementation, but from your perspective you should only see Spring Data JPA.</p>
<p>When designing your entities if you make sure that you use only annotations from the javax.persistence package you will not depend on one concrete JPA implementation (in this case Hibernate) but theoretically you could swap Hibernate for EclipseLink or something else.</p>
<h1 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next"></a>What’s next</h1><p>Knowing all this, you have now to decide what to pick. The good news here is that you don’t need to make a definitive final choice for the technology. This is actually where Spring power resides : as a developer, you concentrate on the business when you write code, and if you do it well, changing the underlying technology is an implementation or configuration detail.</p>
<ol>
<li>Define a data model with POJO classes for the entities, and get/set methods to represent the entity attributes and the relationships to other entities. You will certainly need to annotate the entity classes and fields based on the technology, but for now, POJOs are enough to start with. Just concentrate on the business requirements for now.</li>
</ol>
<ol start="2">
<li>Define interfaces for your DAOs. 1 DAO covers exactly 1 entity, but you will certainly not need a DAO for each of them, as you should be able to load additional entities by navigating the relationships. Define the finder methods following strict naming conventions.</li>
</ol>
<ol start="3">
<li>Based on this, someone else can start working on the services layer, with mocks for your DAOs.</li>
</ol>
<ol start="4">
<li>You learn the different persistence technologies (sql, no-sql) to find the best fit for your needs, and choose one of them. Based on this, you annotate the entities and implement the DAOs (or let spring implement them for you if you choose to use spring-data).</li>
</ol>
<ol start="5">
<li>If the business requirements evolve and your data access technology is not sufficient to support it (say, you started with JDBC and a few entities, but now need a richer data model and JPA is a better choice), you will have to change the implementation of your DAOs, add a few annotations on your entities and change the spring configuration (add an EntityManagerFactory definition). The rest of your business code should not see other impacts from your change.</li>
</ol>
<h1 id="Note-Transaction-Management"><a href="#Note-Transaction-Management" class="headerlink" title="Note : Transaction Management"></a>Note : Transaction Management</h1><p>Spring provides an API for transaction management. If you plan to use spring for the data access, you should also use spring for transaction management, as they integrate together really well. For each data access technology supported by spring, there is a matching transaction manager for local transactions, or you can choose JTA if you need distributed transactions. All of them implement the same API, so that (once again) the technology choice is just a matter a configuration that can be changed without further impact on the business code.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/08/springDAO/" data-id="cjjgs7mir0009fgl7ua51ex7z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-DAO-Spring-JDBC-Spring-ORM-Spring-DATA/">Spring DAO, Spring JDBC, Spring ORM, Spring DATA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-testsCategry" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/29/testsCategry/" class="article-date">
  <time datetime="2018-05-29T10:27:26.619Z" itemprop="datePublished">2018-05-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/test/">test</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/testsCategry/">Blue-green Deployments, A/B Testing, and Canary Releases</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Blue-Green-Deployments"><a href="#Blue-Green-Deployments" class="headerlink" title="Blue Green Deployments"></a>Blue Green Deployments</h2><p>Pleaes see Martin Fowler’s link about blue-green deployments. It gives the overall gist. It’s basically a technique for releasing your application in a predictable manner with an goal of reducing any downtime associated with a release. It’s a quick way to prime your app before releasing, and also quickly roll back if you find issues.</p>
<p>Simply, you have two identical environments (infrastructure) with the “green” environment hosting the current production apps (app1 version1, app2 version1, app3 version1 for example):</p>
<p><img src="/2018/05/29/testsCategry/greendeployment.png" alt=""></p>
<p>Now, when you’re ready to make a change to app2 for example and upgrade it to v2, you’d do so in the “blue environment”. In that environment you deploy the new version of the app, run smoke tests, and any other tests (including those to exercise/prime the OS, cache, CPU, etc). When things look good, you change the loadbalancer/reverse proxy/router to point to the blue environment:</p>
<p><img src="/2018/05/29/testsCategry/bluedeployment.png" alt=""></p>
<p>You monitor for any failures or exceptions because of the release. If everything looks good, you can eventually shut down the green environment and use it to stage any new releases. If not, you can quickly rollback to the green environment by pointing the loadbalancer back.</p>
<p>Sounds good in theory. But there are things to watch out for.</p>
<p>Long running transactions in the green environment. When you switch over to blue, you have to gracefully handle those outstanding transactions as well as the new ones. This also can become troublesome if your DB backends cannot handle this (see below)<br>Enterprise deployments are not typically amenable to “microservice” style deployments – that is, you may have a hybrid of microservice style apps, and some traditional, difficult-to-change-apps working together. Coordinating between the two for a blue-green deployment can still lead to downtime<br>Database migrations can get really tricky and would have to be migrated/rolledback alongside the app deployments. There are good tools and techniques for doing this, but in an environment with traditional RDBMS, NoSQL, and file-system backed DBs, these things really need to be thought through ahead of time; blindly saying you’re doing Blue Green deployments doesn’t help anything – actually could hurt.<br>You need to have the infrastructure to do this<br>If you try to do this on non-isolated infrastructure (VMs, Docker, etc), you run the risk of destroying your blue AND green environments</p>
<p>As I’ve said, there are good techniques to overcome these challenges and make this deployment style work out very nicely, including plugging into a continuous deployment pipeline, but don’t jump into it trivially.</p>
<h2 id="A-B-Testing"><a href="#A-B-Testing" class="headerlink" title="A/B Testing"></a>A/B Testing</h2><p>A/B testing is NOT blue-green deployments. I’ve run into groups that mistake this. A/B testing is a way of testing features in your application for various reasons like usability, popularity, noticeability, etc, and how those factors influence the bottom line. It’s usually associated with UI parts of the app, but of course the backend services need to be available to do this. You can implement this with application-level switches (ie, smart logic that knows when to display certain UI controls), static switches (in the application), and also using Canary releases (as discussed below).</p>
<p><img src="/2018/05/29/testsCategry/abtesting.png" alt=""></p>
<p>The difference between blue-green deployments and A/B testing is A/B testing is for measuring functionality in the app. Blue-green deployments is about releasing new software safely and rolling back predictably. You can obviously combine them: use blue-green deployments to deploy new features in an app that can be used for A/B testing.</p>
<h2 id="Canary-releases"><a href="#Canary-releases" class="headerlink" title="Canary releases"></a>Canary releases</h2><p>Lastly, Canary releases are a way of sending out a new version of your app into production that plays the role of a “canary” to get an idea of how it will perform (integrate with other apps, CPU, memory, disk usage, etc). It’s another release strategy that can mitigate the fact that regardless of the immense level of testing you do in lower environments you will still have some bugs in production. Canary releases let you test the waters before pulling the trigger on a full release.</p>
<p><img src="/2018/05/29/testsCategry/canarydeployment.png" alt=""></p>
<p>The faster feedback you get, the faster you can fail the deployment, or proceed cautiously. For some of the same reasons as the blue-green deployments, be careful of things above to watch out for; ie, database changes can still trip you up.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>All of these strategies can be implemented regardless of whether you’re using a particular cloud technology. But as you can imagine, technologies such as Docker and Kubernetes can be greatly helpful (if not even have provisions built in) for implementing these strategies. For example, OpenShift and Fabric8 greatly simplifies using Docker and Kubernetes by providing the tooling necessary to use these technologies without having to worry about the underlying details.</p>
<p>ref. <a href="http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/" target="_blank" rel="noopener">http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/29/testsCategry/" data-id="cjjgs7miu000bfgl78lltj1p1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/A-B-Testing/">A/B Testing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Blue-green-Deployments/">Blue-green Deployments</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Canary-Releases/">Canary Releases</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-backpressure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/15/backpressure/" class="article-date">
  <time datetime="2018-05-15T06:26:09.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/backpressure/">Backpressure</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>背压（Backpressure）可能是所有想要深入运用RxJava的朋友必须理解的一个概念。<br>关于它的介绍，我本意是想写在RxJava2.0更新介绍的文章里的，可是写着写着发现，要完整介绍这个概念需要花费的篇幅太长，恰好目前对于背压的介绍文章比较少，所以决定单独拿出来，自成一篇。而关于RxJava2.0的文章修改之后就会发出来和大家探讨。<br>如果对于RxJava不是很熟悉，那么在这篇文章之前，我希望大家先看看那篇关于Rxjava最友好的文章，可以帮助大家很顺畅的了解RxJava。</p>
<h1 id="从场景出发"><a href="#从场景出发" class="headerlink" title="从场景出发"></a>从场景出发</h1><p>让我们先忘掉背压（Backpressure）这个概念，从RxJava一个比较常见的工作场景说起。<br>RxJava是一个观察者模式的架构，当这个架构中被观察者(Observable)和观察者(Subscriber)处在不同的线程环境中时，由于者各自的工作量不一样，导致它们产生事件和处理事件的速度不一样，这就会出现两种情况：</p>
<p>被观察者产生事件慢一些，观察者处理事件很快。那么观察者就会等着被观察者发送事件，（好比观察者在等米下锅，程序等待，这没有问题）。关于背压（Backpressure）<br>被观察者产生事件的速度很快，而观察者处理很慢。那就出问题了，如果不作处理的话，事件会堆积起来，最终挤爆你的内存，导致程序崩溃。（好比被观察者生产的大米没人吃，堆积最后就会烂掉）。</p>
<p>下面我们用代码演示一下这种崩溃的场景：</p>
<pre><code>//被观察者在主线程中，每1ms发送一个事件
Observable.interval(1, TimeUnit.MILLISECONDS)
            //.subscribeOn(Schedulers.newThread())
            //将观察者的工作放在新线程环境中
            .observeOn(Schedulers.newThread())
            //观察者处理每1000ms才处理一个事件
            .subscribe(new Action1&lt;Long&gt;() {
                  @Override
                  public void call(Long aLong) {
                      try {
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      Log.w(&quot;TAG&quot;,&quot;----&gt;&quot;+aLong);
                  }
              });
</code></pre><p>在上面的代码中，被观察者发送事件的速度是观察者处理速度的1000倍<br>这段代码运行之后：</p>
<pre><code>...
Caused by: rx.exceptions.MissingBackpressureException
...
...
</code></pre><p>抛出MissingBackpressureException往往就是因为，被观察者发送事件的速度太快，而观察者处理太慢，而且你还没有做相应措施，所以报异常。<br>而这个MissingBackpressureException异常里面就包含了Backpressure这个单词，看来背压肯定和这种异常情况有关系。<br>那么背压（Backpressure）到底是什么呢？</p>
<h1 id="关于背压（Backpressure）"><a href="#关于背压（Backpressure）" class="headerlink" title="关于背压（Backpressure）"></a>关于背压（Backpressure）</h1><p>我这两天翻阅了大量的中文和英文资料，我发现中文资料中，很多人对于背压（Backpressure）的理解是有很大问题的，有的人把它看作一个需要避免的问题，或者程序的异常，有的人则干脆避而不谈，模棱两可，着实让人尴尬。<br>通过参考和对比大量的相关资料，我在这里先对背压（Backpressure）做一个明确的定义：背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略<br>简而言之，背压是流速控制的一种策略。<br>需要强调两点：</p>
<p>背压策略的一个前提是异步环境，也就是说，被观察者和观察者处在不同的线程环境中。<br>背压（Backpressure）并不是一个像flatMap一样可以在程序中直接使用的操作符，他只是一种控制事件流速的策略。</p>
<p>那么我们再回看上面的程序异常就很好理解了，就是当被观察者发送事件速度过快的情况下，我们没有做流速控制，导致了异常。<br>那么背压（Backpressure）策略具体是哪如何实现流速控制的呢？</p>
<h1 id="响应式拉取（reactive-pull）"><a href="#响应式拉取（reactive-pull）" class="headerlink" title="响应式拉取（reactive pull）"></a>响应式拉取（reactive pull）</h1><p>首先我们回忆之前那篇关于Rxjava最友好的文章，里面其实提到，在RxJava的观察者模型中，被观察者是主动的推送数据给观察者，观察者是被动接收的。而响应式拉取则反过来，观察者主动从被观察者那里去拉取数据，而被观察者变成被动的等待通知再发送数据。<br>结构示意图如下：<br><img src="/2018/05/15/backpressure/1627a7f426088d78.png" alt=""><br>观察者可以根据自身实际情况按需拉取数据，而不是被动接收（也就相当于告诉上游观察者把速度慢下来），最终实现了上游被观察者发送事件的速度的控制，实现了背压的策略。<br>代码实例如下：</p>
<pre><code>//被观察者将产生100000个事件
Observable observable=Observable.range(1,100000);
class MySubscriber extends Subscriber&lt;T&gt; {
    @Override
    public void onStart() {
    //一定要在onStart中通知被观察者先发送一个事件
      request(1);
    }

    @Override
    public void onCompleted() {
        ...
    }

    @Override
    public void onError(Throwable e) {
        ...
    }

    @Override
    public void onNext(T n) {
        ...
        ...
        //处理完毕之后，在通知被观察者发送下一个事件
        request(1);
    }
}

observable.observeOn(Schedulers.newThread())
        .subscribe(MySubscriber);
</code></pre><p>在代码中，传递事件开始前的onstart()中，调用了request(1)，通知被观察者先发送一个事件，然后在onNext()中处理完事件，再次调用request(1)，通知被观察者发送下一个事件….</p>
<p>注意在onNext()方法中，最好最后再调用request()方法.</p>
<p>如果你想取消这种backpressure 策略，调用quest(Long.MAX_VALUE)即可。<br>实际上，在上面的代码中，你也可以不需要调用request(n)方法去拉取数据，程序依然能完美运行，这是因为range –&gt; observeOn,这一段中间过程本身就是响应式拉取数据，observeOn这个操作符内部有一个缓冲区，Android环境下长度是16，它会告诉range最多发送16个事件，充满缓冲区即可。不过话说回来，在观察者中使用request(n)这个方法可以使背压的策略表现得更加直观，更便于理解。<br>如果你足够细心，会发现，在开头展示异常情况的代码中，使用的是interval这个操作符，但是在这里使用了range操作符，为什么呢？<br>这是因为interval操作符本身并不支持背压策略，它并不响应request(n)，也就是说，它发送事件的速度是不受控制的，而range这类操作符是支持背压的，它发送事件的速度可以被控制。<br>那么到底什么样的Observable是支持背压的呢？</p>
<h1 id="Hot-and-Cold-Observables"><a href="#Hot-and-Cold-Observables" class="headerlink" title="Hot and Cold Observables"></a>Hot and Cold Observables</h1><p>需要说明的时，Hot Observables 和cold Observables并不是严格的概念区分，它只是对于两类Observable形象的描述</p>
<p>Cold Observables：指的是那些在订阅之后才开始发送事件的Observable（每个Subscriber都能接收到完整的事件）。<br>Hot Observables:指的是那些在创建了Observable之后，（不管是否订阅）就开始发送事件的Observable</p>
<p>其实也有创建了Observable之后调用诸如publish()方法就可以开始发送事件的,这里咱们暂且忽略。</p>
<p>我们一般使用的都是Cold Observable，除非特殊需求，才会使用Hot Observable,在这里，Hot Observable这一类是不支持背压的，而是Cold Observable这一类中也有一部分并不支持背压（比如interval，timer等操作符创建的Observable）。<br>懵逼了吧？</p>
<p>Tips: 都是Observable，结果有的支持背压，有的不支持，这就是RxJava1.X的一个问题。在2.0中，这种问题已经解决了，以后谈到2.0时再细说。</p>
<p>在那些不支持背压策略的操作符中使用响应式拉取数据的话，还是会抛出MissingBackpressureException。<br>那么，不支持背压的Observevable如何做流速控制呢？</p>
<h1 id="流速控制相关的操作符"><a href="#流速控制相关的操作符" class="headerlink" title="流速控制相关的操作符"></a>流速控制相关的操作符</h1><h2 id="过滤（抛弃）"><a href="#过滤（抛弃）" class="headerlink" title="过滤（抛弃）"></a>过滤（抛弃）</h2><p>就是虽然生产者产生事件的速度很快，但是把大部分的事件都直接过滤（浪费）掉，从而间接的降低事件发送的速度。<br>相关类似的操作符：Sample，ThrottleFirst….<br>以sample为例，</p>
<pre><code>Observable.interval(1, TimeUnit.MILLISECONDS)
            .observeOn(Schedulers.newThread())
            //这个操作符简单理解就是每隔200ms发送里时间点最近那个事件，
            //其他的事件浪费掉
              .sample(200,TimeUnit.MILLISECONDS)
              .subscribe(new Action1&lt;Long&gt;() {
                  @Override
                  public void call(Long aLong) {
                      try {
                          Thread.sleep(200);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      Log.w(&quot;TAG&quot;,&quot;----&gt;&quot;+aLong);
                  }
              });
</code></pre><p>这是以杀敌一千，自损八百的方式解决这个问题，因为抛弃了绝大部分的事件，而在我们使用RxJava 时候，我们自己定义的Observable产生的事件可能都是我们需要的，一般来说不会抛弃，所以这种方案有它的缺陷。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>就是虽然被观察者发送事件速度很快，观察者处理不过来，但是可以选择先缓存一部分，然后慢慢读。<br>相关类似的操作符：buffer，window…<br>以buffer为例，</p>
<pre><code>Observable.interval(1, TimeUnit.MILLISECONDS)

            .observeOn(Schedulers.newThread())
            //这个操作符简单理解就是把100毫秒内的事件打包成list发送
            .buffer(100,TimeUnit.MILLISECONDS)
              .subscribe(new Action1&lt;List&lt;Long&gt;&gt;() {
                  @Override
                  public void call(List&lt;Long&gt; aLong) {
                      try {
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      Log.w(&quot;TAG&quot;,&quot;----&gt;&quot;+aLong.size());
                  }
              });
</code></pre><h2 id="两个特殊操作符"><a href="#两个特殊操作符" class="headerlink" title="两个特殊操作符"></a>两个特殊操作符</h2><p>对于不支持背压的Observable除了使用上述两类生硬的操作符之外，还有更好的选择：onBackpressurebuffer，onBackpressureDrop。</p>
<p>onBackpressurebuffer：把observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。<br>onBackpressureDrop：将observable发送的事件抛弃掉，直到subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。</p>
<p>下面，我们以onBackpressureDrop为例说说用法：</p>
<pre><code>Observable.interval(1, TimeUnit.MILLISECONDS)
            .onBackpressureDrop()
            .observeOn(Schedulers.newThread())
           .subscribe(new Subscriber&lt;Long&gt;() {

                @Override
                public void onStart() {
                    Log.w(&quot;TAG&quot;,&quot;start&quot;);
                    request(1);
                }

                @Override
                  public void onCompleted() {

                  }
                  @Override
                  public void onError(Throwable e) {
                        Log.e(&quot;ERROR&quot;,e.toString());
                  }

                  @Override
                  public void onNext(Long aLong) {
                      Log.w(&quot;TAG&quot;,&quot;----&gt;&quot;+aLong);
                      try {
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
              });
</code></pre><p>这段代码的输出：</p>
<pre><code>W/TAG: start
W/TAG: ----&gt;0
W/TAG: ----&gt;1
W/TAG: ----&gt;2
W/TAG: ----&gt;3
W/TAG: ----&gt;4
W/TAG: ----&gt;5
W/TAG: ----&gt;6
W/TAG: ----&gt;7
W/TAG: ----&gt;8
W/TAG: ----&gt;9
W/TAG: ----&gt;10
W/TAG: ----&gt;11
W/TAG: ----&gt;12
W/TAG: ----&gt;13
W/TAG: ----&gt;14
W/TAG: ----&gt;15
W/TAG: ----&gt;1218
W/TAG: ----&gt;1219
W/TAG: ----&gt;1220
...
</code></pre><p>之所以出现0-15这样连贯的数据，就是是因为observeOn操作符内部有一个长度为16的缓存区，它会首先请求16个事件缓存起来….<br>你可能会觉得这两个操作符和上面讲的过滤和缓存很类似，确实，功能上是有些类似，但是这两个操作符提供了更多的特性，那就是可以响应下游观察者的request(n)方法了，也就是说，使用了这两种操作符，可以让原本不支持背压的Observable“支持”背压了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>背压是一种策略，具体措施是下游观察者通知上游的被观察者发送事件<br>背压策略很好的解决了异步环境下被观察者和观察者速度不一致的问题<br>在RxJava1.X中，同样是Observable，有的不支持背压策略，导致某些情况下，显得特别麻烦，出了问题也很难排查，使得RxJava的学习曲线变得十份陡峭。</p>
<p>这篇文章并不是为了让你学习在RxJava1.0中使用背压（如果你之前不了解背压的话），因为在1.0中，背压的设计并不十分完美。而是希望你对背压有一个全面清晰的认识，对于它在RxJava1.0中的设计缺陷有所了解即可。</p>
<p>链接：<a href="https://juejin.im/post/582d413c8ac24700619cceed" target="_blank" rel="noopener">https://juejin.im/post/582d413c8ac24700619cceed</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/15/backpressure/" data-id="cjjgs7mi40000fgl7qpaayond" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Backpressure/">Backpressure</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-transactions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/15/transactions/" class="article-date">
  <time datetime="2018-05-15T06:26:09.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/transactions/">可靠消息最终一致性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>消息发送一致性：是指产生消息的业务动作与消息发送的一致。也就是说，如果业务操作成功，那么由这个业务操作所产生的消息一定要成功投递出去(一般是发送到kafka、rocketmq、rabbitmq等消息中间件中)，否则就丢消息。</p>
<p>柔性事务、可靠消息最终一致性、异步确保性</p>
<p> 下面用伪代码进行演示消息发送和投递的不可靠性：</p>
<p>1、先进行数据库操作，再发送消息</p>
<pre><code>public void test1(){
//1 数据库操作
//2 发送MQ消息
}
</code></pre><p>这种情况下无法保证数据库操作与发送消息的一致性，因为可能数据库操作成功，发送消息失败</p>
<p>2、先发送消息，再操作数据库</p>
<pre><code>public void test1(){
//1 发送MQ消息
//2 数据库操作
}
</code></pre><p>这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败</p>
<p>3、在数据库事务中，先发送消息，后操作数据库</p>
<pre><code>@Transactional
public void test1(){
//1 发送MQ消息
//2 数据库操作
}
</code></pre><p>这里使用spring 的@Transactional注解，方法里面的操作都在一个事务中。同样无法保证一致性，因为发送消息成功了，数据库操作失败的情况下，数据库操作是回滚了，但是MQ消息没法进行回滚。</p>
<p>4、在数据库事务中，先操作数据库，后发送消息</p>
<pre><code>@Transactional
public void test1(){
//1 数据库操作
//2 发送MQ消息
}
</code></pre><p>这种情况下，貌似没有问题，如果发送MQ消息失败，抛出异常，事务一定会回滚(加上了@Transactional注解后，spring方法抛出异常后，会自动进行回滚)。</p>
<p>这只是一个假象，因为发送MQ消息可能事实上已经成功，如果是响应超时导致的异常。这个时候，数据库操作依然回滚，但是MQ消息实际上已经发送成功，导致不一致。</p>
<p>5、使用JTA事务管理器</p>
<p>前面通过spring的@Transactional注解加在方法上，来开启事务。其实有一个条件没有明确的说出来，就是我们配置的事务管理器是DataSourceTransactionManager。</p>
<p>事实上，Spring还提供了另外一个分布式事务管理器JtaTransactionManager。这个是使用XA两阶段提交来保证事务的一致性。当然前提是，你的消息中间件是实现了JMS规范中事务消息相关API（回顾前面我们介绍JTA规范时，提到DB、MQ都只是资源管理器RM，对于事务管理器来说，二者是等价的）。</p>
<p>因此如果你满足了2个条件：1、使用JtaTransactionManager 2、DB、MQ分别实现了JDBC、JMS规范中规定的RM应该实现的两阶段提交的API，就可以保证消息发送的一致性。</p>
<p>DB作为RM，一般都是支持两阶段提交的。不过，一些MQ中间件并不支持，所以你要找到支持两阶段提交的MQ中间件。另外，JtaTransactionManager只是一个代理，你需要提供一个真实的事务管理器(TM)实现。如前面提到了atomikos公司，就有这样的产品。</p>
<p>但是笔者依然不建议，这样玩。因为XA两阶段提交性能低，我们使用消息中间件就是为了异步解耦，这种情况，虽然保证了一致性，但是响应时间却大大增加，系统可用性降低。</p>
<p>那么如何保证，数据库操作和消息发送的一致性呢？</p>
<p>两种方案：一种是基于MQ的事务消息，以下展示了RocketMQ的事务消息机制。<br><img src="/2018/05/15/transactions/1517928467227006042.png" alt=""></p>
<p>事务消息的逻辑，由发送端 Producer进行保证(消费端无需考虑)</p>
<p>首先，发送一个事务消息，这个时候，RocketMQ将消息状态标记为Prepared，注意此时这条消息消费者是无法消费到的。</p>
<p>接着，执行业务代码逻辑，可能是一个本地数据库事务操作</p>
<p>最后，确认发送消息，这个时候，RocketMQ将消息状态标记为可消费，这个时候消费者，才能真正的保证消费到这条数据。</p>
<p>如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<p>如果消费失败怎么办？阿里提供给我们的解决方法是：人工解决。</p>
<p>另外一种实现，并不是所有的mq都支持事务消息。也就是消息一旦发送到消息队列中，消费者立马就可以消费到。此时可以使用独立消息服务、或者本地事务表。</p>
<p><img src="/2018/05/15/transactions/1517928501647001515.png" alt=""></p>
<p>可以看到，其实就是将消息先发送到一个我们自己编写的一个”独立消息服务”应用中，刚开始处于prepare状态，业务逻辑处理成功后，确认发送消息，这个时候”独立消息服务”才会真正的把消息发送给消息队列。消费者消费成功后，ack时，除了对消息队列进行ack(图中没有画出)，对于独立消息服务也要进行ack，”独立消息服务”一般是把这条消息删除。而定时扫描prepare状态的消息，向消息发送端(生产者)确认的工作也由独立消息服务来完成。</p>
<p>对于”本地事务表”，其实和”独立消息服务”的作用类似，只不过”独立消息服务”是需要独立部署的，而”本地事务表”是将”独立消息服务”的功能内嵌到应用中。</p>
<p><a href="http://www.tianshouzhi.com/api/tutorials/distributed_transaction/389" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/distributed_transaction/389</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/15/transactions/" data-id="cjjgs7miw000dfgl752pp667l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事务/">事务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-springCloud" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/springCloud/" class="article-date">
  <time datetime="2018-05-10T08:15:18.779Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/springCloud/">Spring Cloud</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-cloud-组件"><a href="#Spring-cloud-组件" class="headerlink" title="Spring cloud 组件"></a>Spring cloud 组件</h1><p><img src="/2018/05/10/springCloud/1523696433477.png" alt=""></p>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><p>A source of name/value property pairs. The underlying source object may be of any type T that encapsulates properties. Examples include Properties objects, Map objects, ServletContext and ServletConfig objects (for access to init parameters). When working with @Configuration classes that the @PropertySource annotation provides a convenient and declarative way of adding property sources to the enclosing Environment.</p>
<p>The default property source for external configuration added by the bootstrap process is the Config Server, but you can add additional sources by adding beans of type PropertySourceLocator to the bootstrap context (via META-INF/spring.factories). You could use this to insert additional properties from a different server, or from a database, for instance.</p>
<h2 id="bootstrap-yml-bootstrap-properties-amp-application-yml-application-properties"><a href="#bootstrap-yml-bootstrap-properties-amp-application-yml-application-properties" class="headerlink" title="bootstrap.yml(bootstrap.properties) &amp; application.yml(application.properties)"></a>bootstrap.yml(bootstrap.properties) &amp; application.yml(application.properties)</h2><p>A Spring Cloud application operates by creating a “bootstrap” context, which is a parent context for the main application. Out of the box it is responsible for loading configuration properties from the external sources, and also decrypting properties in the local external configuration files.</p>
<h5 id="Typically-bootstrap-yml-bootstrap-properties-contains-two-properties"><a href="#Typically-bootstrap-yml-bootstrap-properties-contains-two-properties" class="headerlink" title="Typically bootstrap.yml(bootstrap.properties) contains two properties:"></a>Typically bootstrap.yml(bootstrap.properties) contains two properties:</h5><ul>
<li>location of the configuration server (spring.cloud.config.uri)</li>
<li>name of the application (spring.application.name)</li>
</ul>
<p>Upon startup, Spring Cloud makes an HTTP call to the config server with the name of the application and retrieves back that application’s configuration.</p>
<h5 id="application-yml-application-properties"><a href="#application-yml-application-properties" class="headerlink" title="application.yml(application.properties)"></a>application.yml(application.properties)</h5><p>Contains standard application configuration - typically default configuration since any configuration retrieved during the bootstrap process will override configuration defined here.</p>
<p>bootstrap.yml (or properties) have lower precedence than the application.yml (or properties) and any other property sources that are added to the child as a normal part of the process of creating a Spring Boot application. </p>
<p>#Spring Cloud Context<br>provides utilities and special services for the ApplicationContext of a Spring Cloud application (bootstrap context, encryption, refresh scope and environment endpoints). </p>
<p>Normal Spring application context behaviour rules apply to property resolution: properties from a child context override those in the parent, by name and also by property source name (if the child has a property source with the same name as the parent, the one from the parent is not included in the child).</p>
<p>#Endpoints</p>
<p>For a Spring Boot Actuator application there are some additional management endpoints:</p>
<p>POST to /env to update the Environment and rebind @ConfigurationProperties and log levels<br>/refresh for re-loading the boot strap context and refreshing the @RefreshScope beans<br>/restart for closing the ApplicationContext and restarting it (disabled by default)<br>/pause and /resume for calling the Lifecycle methods (stop() and start() on the ApplicationContext)</p>
<p>#Spring Cloud Commons<br>is a set of abstractions and common classes used in different Spring Cloud implementations (eg. Spring Cloud Netflix vs. Spring Cloud Consul).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/10/springCloud/" data-id="cjjgs7mio0006fgl7qob21for" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/08/docker/" class="article-date">
  <time datetime="2018-05-08T04:52:08.000Z" itemprop="datePublished">2018-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/08/docker/">Docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作虚拟机"><a href="#操作虚拟机" class="headerlink" title="操作虚拟机"></a>操作虚拟机</h1><p>列出虚拟机</p>
<pre><code>$docker-machine ls
</code></pre><p>启动虚拟机</p>
<pre><code>$ docker-machine start default
</code></pre><p>停止虚拟机</p>
<pre><code>$ docker-machine stop default
</code></pre><p>查看虚拟机IP</p>
<pre><code>$ docker-machine ip
</code></pre><p>查看虚拟机环境</p>
<pre><code>$ docker-machine env
</code></pre><h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><hr>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器并启动bash（交互方式）:</p>
<pre><code>$docker run -i -t &lt;image_name/continar_id&gt; /bin/bash
</code></pre><p>启动容器以后台方式运行(更通用的方式）：</p>
<pre><code>$docker run -d -it  image_name
</code></pre><p>ps：这里的 image_name 包含了tag：hello.demo.kdemo:v1.0<br>附着到容器</p>
<h3 id="附着到正在运行的容器"><a href="#附着到正在运行的容器" class="headerlink" title="附着到正在运行的容器"></a>附着到正在运行的容器</h3><pre><code>docker attach &lt;id/container_name&gt;
</code></pre><p>进入正在运行的容器内部，同时运行bash(比attach更好用)</p>
<pre><code>docker exec -t -i &lt;id/container_name&gt;  /bin/bash
</code></pre><p>ps：docker exec是如此的有用，以至于我们通常是将其封装为一个脚本，放到全局可调用的地方，比如，可以写成一个indocker.sh：</p>
<pre><code>$cat indocker.sh 
docker exec -t -i $1 /bin/bash

# 查看需要附着的容器id
$docker ps | less -S
CONTAINER ID        IMAGE                                                 
9cf7b563f689        hello.demo.kdemo:v160525.202747

$./indocker.sh 9cf7b563f689 
</code></pre><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><pre><code>docker logs &lt;id/container_name&gt;
</code></pre><p>实时查看日志输出</p>
<pre><code>docker logs -f &lt;id/container_name&gt; (类似 tail -f) (带上时间戳-t）
</code></pre><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>列出当前所有正在运行的container</p>
<pre><code>$docker ps
</code></pre><p>用一行列出所有正在运行的container（容器多的时候非常清晰）</p>
<pre><code>$docker ps | less -S
</code></pre><p>列出所有的container</p>
<pre><code>$docker ps -a  
</code></pre><p>列出最近一次启动的container</p>
<pre><code>$docker ps -l 
</code></pre><p>显示一个运行的容器里面的进程信息</p>
<pre><code>$docker top Name/ID  
</code></pre><p>查看容器内部详情细节：</p>
<pre><code>$docker inspect &lt;id/container_name&gt;
</code></pre><p>在容器中安装新的程序</p>
<pre><code>$docker run image_name apt-get install -y app_name  

Note： 在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。
</code></pre><p>从容器里面拷贝文件/目录到本地一个路径</p>
<pre><code>$docker cp Name:/container_path to_path  
$docker cp ID:/container_path to_path
</code></pre><p>保存对容器的修改（commit） 当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。</p>
<pre><code>$docker commit ID new_image_name  

Note： image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。
</code></pre><p>删除单个容器</p>
<pre><code>$docker rm Name/ID 

-f, –force=false; -l, –link=false Remove the specified link and not the underlying container; -v, –volumes=false Remove the volumes associated to the container
</code></pre><p>删除所有容器</p>
<pre><code>$docker rm `docker ps -a -q`  
</code></pre><p>停止、启动、杀死、重启一个容器</p>
<pre><code>$docker stop Name/ID  
$docker start Name/ID  
$docker kill Name/ID  
$docker restart name/ID
</code></pre><h1 id="操作Image"><a href="#操作Image" class="headerlink" title="操作Image"></a>操作Image</h1><hr>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><pre><code>$sudo docker images

-a, –all=false Show all images; –no-trunc=false Don’t truncate output; -q, –quiet=false Only show numeric IDs
</code></pre><h3 id="从dockerhub检索image"><a href="#从dockerhub检索image" class="headerlink" title="从dockerhub检索image"></a>从dockerhub检索image</h3><pre><code>$docker search image_name
</code></pre><h3 id="下载image"><a href="#下载image" class="headerlink" title="下载image"></a>下载image</h3><pre><code>$docker pull image_name
</code></pre><h3 id="删除一个或者多个镜像"><a href="#删除一个或者多个镜像" class="headerlink" title="删除一个或者多个镜像;"></a>删除一个或者多个镜像;</h3><pre><code>$docker rmi image_name  

-f, –force=false Force; –no-prune=false Do not delete untagged parents
</code></pre><h3 id="显示一个镜像的历史"><a href="#显示一个镜像的历史" class="headerlink" title="显示一个镜像的历史;"></a>显示一个镜像的历史;</h3><pre><code>$docker history image_name
</code></pre><h3 id="发布docker镜像"><a href="#发布docker镜像" class="headerlink" title="发布docker镜像"></a>发布docker镜像</h3><pre><code>$docker push new_image_name
</code></pre><p>ps:要发布到私有Registry中的镜像，在镜像命名中需要带上Registry的域名（如果非80端口，同时需要带上端口号）比如：</p>
<p>$docker push dockerhub.yourdomain.com:443/hello.demo.kdemo:v1.0</p>
<h3 id="拉取docker镜像"><a href="#拉取docker镜像" class="headerlink" title="拉取docker镜像"></a>拉取docker镜像</h3><pre><code>$docker pull image_name
</code></pre><h1 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h1><hr>
<h3 id="查看docker0的网络-宿主机上操作"><a href="#查看docker0的网络-宿主机上操作" class="headerlink" title="查看docker0的网络(宿主机上操作)"></a>查看docker0的网络(宿主机上操作)</h3><pre><code>$ip a show docker0
</code></pre><h3 id="查看容器的IP地址"><a href="#查看容器的IP地址" class="headerlink" title="查看容器的IP地址"></a>查看容器的IP地址</h3><pre><code>$docker inspect -f &apos;{{ .NetworkSettings.IPAddress }}&apos; &lt;id、container_name&gt;
</code></pre><h3 id="附着到容器内部查看其内部ip："><a href="#附着到容器内部查看其内部ip：" class="headerlink" title="附着到容器内部查看其内部ip："></a>附着到容器内部查看其内部ip：</h3><pre><code>$ip a show eth0
</code></pre><h1 id="查看docker基础信息"><a href="#查看docker基础信息" class="headerlink" title="查看docker基础信息"></a>查看docker基础信息</h1><hr>
<h3 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="查看docker版本"></a>查看docker版本</h3><pre><code>$docker version
</code></pre><h3 id="查看docker系统的信息"><a href="#查看docker系统的信息" class="headerlink" title="查看docker系统的信息"></a>查看docker系统的信息</h3><pre><code>$docker info
</code></pre><h1 id="从容器内拷贝文件到主机"><a href="#从容器内拷贝文件到主机" class="headerlink" title="从容器内拷贝文件到主机"></a>从容器内拷贝文件到主机</h1><p>首先要知道virtualbox与windows的共享目录例如/c/Users。</p>
<pre><code>$ docker cp &lt;containerId&gt;:/容器内文件path 共享目录  
</code></pre><p>启动或未启动的容器都可以拷贝。</p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Compose is a tool for defining and running multi-container Docker applications. </p>
<p>查看命令详细参数：例如docker-compose run -h</p>
<pre><code> -d, --detach              Detached mode: Run containers in the background,
                           print new container names. Incompatible with
                           --abort-on-container-exit.
--no-color                 Produce monochrome output.
--quiet-pull               Pull without printing progress information
--no-deps                  Don&apos;t start linked services.
--force-recreate           Recreate containers even if their configuration
                           and image haven&apos;t changed.
--always-recreate-deps     Recreate dependent containers.
                           Incompatible with --no-recreate.
--no-recreate              If containers already exist, don&apos;t recreate
                           them. Incompatible with --force-recreate and -V.
--no-build                 Don&apos;t build an image, even if it&apos;s missing.
--no-start                 Don&apos;t start the services after creating them.
--build                    Build images before starting containers.
--abort-on-container-exit  Stops all containers if any container was
                           stopped. Incompatible with -d.
-t, --timeout TIMEOUT      Use this timeout in seconds for container
                           shutdown when attached or when containers are
                           already running. (default: 10)
-V, --renew-anon-volumes   Recreate anonymous volumes instead of retrieving
                           data from the previous containers.
--remove-orphans           Remove containers for services not defined
                           in the Compose file.
--exit-code-from SERVICE   Return the exit code of the selected service
                           container. Implies --abort-on-container-exit.
--scale SERVICE=NUM        Scale SERVICE to NUM instances. Overrides the
                           `scale` setting in the Compose file if present.
</code></pre><h3 id="启动所有容器"><a href="#启动所有容器" class="headerlink" title="启动所有容器"></a>启动所有容器</h3><ol>
<li>进入docker-compose.yml所在目录</li>
<li>docker-compose up</li>
</ol>
<h3 id="停止所有容器"><a href="#停止所有容器" class="headerlink" title="停止所有容器"></a>停止所有容器</h3><ol>
<li>进入docker-compose.yml所在目录</li>
<li>docker-compose stop</li>
</ol>
<h3 id="启动或停止指定容器"><a href="#启动或停止指定容器" class="headerlink" title="启动或停止指定容器"></a>启动或停止指定容器</h3><pre><code>docker-compose [up|stop]  docker-compose.yml中设定的容器名
</code></pre><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>当修改dockerfile或者docker-compose时，运行docker-compose build 重建镜像。</p>
<h3 id="重新部署容器"><a href="#重新部署容器" class="headerlink" title="重新部署容器"></a>重新部署容器</h3><pre><code>1. 修改代码，在本地build，生成镜像
2. docker-compose up -d --force-recreate --no-deps --build  discovery
</code></pre><h1 id="主机访问虚拟机中容器"><a href="#主机访问虚拟机中容器" class="headerlink" title="主机访问虚拟机中容器"></a>主机访问虚拟机中容器</h1><p>  本机运行服务直接访问docker容器是访问不到的，需要虚拟机中转。</p>
<p>  假设本机虚拟网卡地址192.168.152.1，虚拟机运行后对外地址192.168.152.131，其中的各docker容器网段为172.17。</p>
<p>  route add -p 172.17.0.0 mask 255.255.255.0 192.168.152.131    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/08/docker/" data-id="cjjgs7mic0001fgl7bvtz4yq0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-classloader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/08/classloader/" class="article-date">
  <time datetime="2018-05-08T04:52:08.000Z" itemprop="datePublished">2018-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Classloader/">Classloader</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/08/classloader/">Classloader</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是-Java-类加载机制"><a href="#什么是-Java-类加载机制" class="headerlink" title="什么是 Java 类加载机制?"></a>什么是 Java 类加载机制?</h1><p>Java 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。</p>
<p>ClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。</p>
<h2 id="Class-文件有哪些来源呢"><a href="#Class-文件有哪些来源呢" class="headerlink" title="Class 文件有哪些来源呢?"></a>Class 文件有哪些来源呢?</h2><p>上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？</p>
<p>首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；</p>
<p>然后，有 Java 内部自带的核心类如 java.lang、java.math、java.io 等 package 内部的类，位于 $JAVA_HOME/jre/lib/ 目录下，如 java.lang.String 类就是定义在 $JAVA_HOME/jre/lib/rt.jar 文件里；</p>
<p>另外，还有 Java 核心扩展类，位于 $JAVA_HOME/jre/lib/ext 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；</p>
<p>最后还有一种，是动态加载远程的 .class 文件。</p>
<p>既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？</p>
<h1 id="哪些-ClassLoader-负责加载上面几类-Class？"><a href="#哪些-ClassLoader-负责加载上面几类-Class？" class="headerlink" title="哪些 ClassLoader 负责加载上面几类 Class？"></a>哪些 ClassLoader 负责加载上面几类 Class？</h1><p>实际上，针对上面四种来源的类，分别有不同的加载器负责加载。</p>
<p>首先，我们来看级别最高的 Java 核心类，即$JAVA_HOME/jre/lib 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 BootstrapClassLoader 加载器负责加载，它也被称作 根加载器／引导加载器。注意，BootstrapClassLoader 比较特殊，它不继承 ClassLoader，而是由 JVM 内部实现；</p>
<p>然后，需要加载 Java 核心扩展类，即 $JAVA_HOME/jre/lib/ext 目录下的 jar 文件。这些文件由 ExtensionClassLoader 负责加载，它也被称作 扩展类加载器。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 ExtClassLoader 加载；</p>
<p>接下来是开发者在项目中编写的类，这些文件将由 AppClassLoader 加载器进行加载，它也被称作 系统类加载器 System ClassLoader；</p>
<p>最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 findClass() 方法才能得以实现。</p>
<p>因此能看出，Java 里提供了至少四类 ClassLoader 来分别加载不同来源的 Class。</p>
<p>那么，这几种 ClassLoader 是如何协作来加载一个类呢？</p>
<h1 id="这些-ClassLoader-以何种方式来协作加载-String-类呢？"><a href="#这些-ClassLoader-以何种方式来协作加载-String-类呢？" class="headerlink" title="这些 ClassLoader 以何种方式来协作加载 String 类呢？"></a>这些 ClassLoader 以何种方式来协作加载 String 类呢？</h1><p>String 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？</p>
<p>我们来猜想下。</p>
<p>首先，String 类属于 Java 核心类，位于 $JAVA_HOME/jre/lib 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 BootstrapClassLoader 进行加载。没错，它确实是由 BootstrapClassLoader 进行加载。但，这种回答的前提是你已经知道了 String 在 $JAVA_HOME/jre/lib 目录下。</p>
<p>那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 unknown 的类呢？</p>
<p>有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 unknown 的类位于哪里，然后再用对应的加载器去加载。</p>
<p>是的，思路很正确。那应该如何去遍历呢？</p>
<p>比如，可以先遍历用户自己写的类，如果找到了就用 AppClassLoader 去加载；否则去遍历 Java 核心类目录，找到了就用 BootstrapClassLoader 去加载，否则就去遍历 Java 扩展类库，依次类推。</p>
<p>这种思路方向是正确的，不过存在一个漏洞。</p>
<p>假如开发者自己伪造了一个 java.lang.String 类，即在项目中创建一个包java.lang，包内创建一个名为 String 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 java.lang.String 类吗？如何解决这个问题呢？</p>
<p>解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。</p>
<p>在 Java 中，这种实现方式也称作 双亲委托（Delegation Principle）。其实很简单，把 BootstrapClassLoader 想象为核心高层领导人， ExtClassLoader 想象为中层干部， AppClassLoader 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 AppClassLoader 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。</p>
<p>如下图所示：<br><img src="/2018/05/08/classloader/aaa.png" alt=""></p>
<h1 id="真的是按照双亲委托方式进行类加载吗？"><a href="#真的是按照双亲委托方式进行类加载吗？" class="headerlink" title="真的是按照双亲委托方式进行类加载吗？"></a>真的是按照双亲委托方式进行类加载吗？</h1><p>下面通过几个例子来验证上面的加载方式。<br>开发者自定义的类会被 AppClassLoader 加载吗？</p>
<p>在项目中创建一个名为 MusicPlayer 的类文件，内容如下：</p>
<pre><code>package classloader;

public class MusicPlayer {
    public void print() {
        System.out.printf(&quot;Hi I&apos;m MusicPlayer&quot;);
    }
}
</code></pre><p>然后来加载 MusicPlayer。</p>
<pre><code>private static void loadClass() throws ClassNotFoundException {
Class&lt;?&gt; clazz = Class.forName(&quot;classloader.MusicPlayer&quot;);
ClassLoader classLoader = clazz.getClassLoader();
System.out.printf(&quot;ClassLoader is %s&quot;, classLoader.getClass().getSimpleName());
}
</code></pre><p>打印结果为：</p>
<pre><code>ClassLoader is AppClassLoader
</code></pre><p>可以验证，MusicPlayer 是由 AppClassLoader 进行的加载。<br>验证 AppClassLoader 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？</p>
<p>这时发现 AppClassLoader 提供了一个 getParent() 的方法，来打印看看都是什么。</p>
<pre><code>private static void printParent() throws ClassNotFoundException {
        Class&lt;?&gt; clazz = Class.forName(&quot;classloader.MusicPlayer&quot;);
        ClassLoader classLoader = clazz.getClassLoader();
        System.out.printf(&quot;currentClassLoader is %s\n&quot;, classLoader.getClass().getSimpleName());

        while (classLoader.getParent() != null) {
            classLoader = classLoader.getParent();
            System.out.printf(&quot;Parent is %s\n&quot;, classLoader.getClass().getSimpleName());
        }
}
</code></pre><p>打印结果为：</p>
<pre><code>currentClassLoader is AppClassLoader
Parent is ExtClassLoader
</code></pre><p>首先能看到 ExtClassLoader 确实是 AppClassLoader 的双亲，不过却没有看到 BootstrapClassLoader。事实上，上文就提过， BootstrapClassLoader比较特殊，它是由 JVM 内部实现的，所以 ExtClassLoader.getParent() = null。<br>如果把 MusicPlayer 类挪到 $JAVA_HOME/jre/lib/ext 目录下会发生什么？</p>
<p>上文中说了，ExtClassLoader 会加载$JAVA_HOME/jre/lib/ext 目录下所有的 jar 文件。那来尝试下直接把 MusicPlayer 这个类放到 $JAVA_HOME/jre/lib/ext 目录下吧。</p>
<p>利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。</p>
<pre><code>javac classloader/MusicPlayer.java
jar cvf MusicPlayer.jar classloader/MusicPlayer.class
mv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/
</code></pre><p>这时 MusicPlayer.jar 已经被放置与 $JAVA_HOME/jre/lib/ext 目录下，同时把之前的 MusicPlayer 删除，而且这一次刻意使用 AppClassLoader 来加载：</p>
<pre><code>private static void loadClass() throws ClassNotFoundException {
    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader
    Class&lt;?&gt; clazz = appClassLoader.loadClass(&quot;classloader.MusicPlayer&quot;);
    ClassLoader classLoader = clazz.getClassLoader();
    System.out.printf(&quot;ClassLoader is %s&quot;, classLoader.getClass().getSimpleName());
}
</code></pre><p>打印结果为：</p>
<p>ClassLoader is ExtClassLoader</p>
<p>说明即使直接用 AppClassLoader 去加载，它仍然会被 ExtClassLoader 加载到。</p>
<h1 id="从源码角度真正理解双亲委托加载机制"><a href="#从源码角度真正理解双亲委托加载机制" class="headerlink" title="从源码角度真正理解双亲委托加载机制"></a>从源码角度真正理解双亲委托加载机制</h1><p>上面已经通过一些例子了解了双亲委托的一些特性了，下面来看一下它的实现代码，加深理解。</p>
<p>打开 ClassLoader 里的 loadClass() 方法，便是需要分析的源码了。这个方法里做了下面几件事：</p>
<pre><code>1. 检查目标class是否曾经加载过，如果加载过则直接返回；
2. 如果没加载过，把加载请求传递给 parent 加载器去加载；
3. 如果 parent 加载器加载成功，则直接返回；
4. 如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。
</code></pre><p>代码如下：</p>
<pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查是否曾加载过
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 优先让 parent 加载器去加载
                    c = parent.loadClass(name, false);
                } else {
                    // 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // 如果 parent 均没有加载到目标class，调用自身的 findClass() 方法去搜索
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}

// BootstrapClassLoader 会调用 native 方法去 JVM 加载
private native Class&lt;?&gt; findBootstrapClass(String name);
</code></pre><p>看完实现源码相信能够有更完整的理解。</p>
<h1 id="类加载器最酷的一面：自定义类加载器"><a href="#类加载器最酷的一面：自定义类加载器" class="headerlink" title="类加载器最酷的一面：自定义类加载器"></a>类加载器最酷的一面：自定义类加载器</h1><p>前面提到了 Java 自带的加载器 BootstrapClassLoader、AppClassLoader和ExtClassLoader，这些都是 Java 已经提供好的。</p>
<p>而真正有意思的，是 自定义类加载器，它允许我们在运行时可以从本地磁盘或网络上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。</p>
<p>下面来实现一个网络类加载器，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。</p>
<p>后面我还会写作与 热修复／动态更新 相关的文章，这里先学习 Java 层 NetworkClassLoader 相关的原理。</p>
<ol>
<li>作为一个 NetworkClassLoader，它首先要继承 ClassLoader；</li>
<li>然后它要实现ClassLoader内的 findClass() 方法。注意，不是loadClass()方法，因为ClassLoader提供了loadClass()（如上面的源码），它会基于双亲委托机制去搜索某个 class，直到搜索不到才会调用自身的findClass()，如果直接复写loadClass()，那还要实现双亲委托机制；</li>
<li>在 findClass() 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。</li>
</ol>
<p>具体实现代码如下：</p>
<pre><code>/**
 * Load class from network
 */
public class NetworkClassLoader extends ClassLoader {

    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        byte[] classData = downloadClassData(name); // 从远程下载
        if (classData == null) {
            super.findClass(name); // 未找到，抛异常
        } else {
            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class&lt;?&gt; object
        }
        return null;
    }

    private byte[] downloadClassData(String name) {
        // 从 localhost 下载 .class 文件
        String path = &quot;http://localhost&quot; + File.separatorChar + &quot;java&quot; + File.separatorChar + name.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; 

        try {
            URL url = new URL(path);
            InputStream ins = url.openStream();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead = 0;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream
            }
            return baos.toByteArray();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public String getName() {
        System.out.printf(&quot;Real NetworkClassLoader\n&quot;);
        return &quot;networkClassLoader&quot;;
    }
}
</code></pre><p>这个类的作用是从网络上（这里是本人的 local apache 服务器 <a href="http://localhost/java" target="_blank" rel="noopener">http://localhost/java</a> 上）目录里去下载对应的 .class 文件，并转换成 Class&lt;?&gt; 返回回去使用。</p>
<p>下面我们来利用这个 NetworkClassLoader 去加载 localhost 上的 MusicPlayer 类：</p>
<ol>
<li>首先把 MusicPlayer.class 放置于 /Library/WebServer/Documents/java （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；</li>
</ol>
<ol start="2">
<li><p>执行下面一段代码：</p>
<p> String className = “classloader.NetworkClass”;<br> NetworkClassLoader networkClassLoader = new NetworkClassLoader();<br> Class&lt;?&gt; clazz  = networkClassLoader.loadClass(className);</p>
</li>
<li><p>正常运行，加载 <a href="http://localhost/java/classloader/MusicPlayer.class成功。" target="_blank" rel="noopener">http://localhost/java/classloader/MusicPlayer.class成功。</a></p>
</li>
</ol>
<p>可以看出 NetworkClassLoader 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。</p>
<h1 id="类加载器与Web容器"><a href="#类加载器与Web容器" class="headerlink" title="类加载器与Web容器"></a>类加载器与Web容器</h1><p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p>
<p>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>
<ol>
<li><p>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</p>
</li>
<li><p>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</p>
</li>
<li><p>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确</p>
</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中双亲委托机制、自定义加载器等，并开发了自定义的NetworkClassLoader。</p>
<p>当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。</p>
<h1 id="委托原则-Delegation-Principle"><a href="#委托原则-Delegation-Principle" class="headerlink" title="委托原则(Delegation Principle)"></a>委托原则(Delegation Principle)</h1><pre><code>如果一个类还没有被加载，类加载器会委托它的父亲加载器去加载它。
</code></pre><p>这种委托会一直延续，直到到达委托层次的最顶层，由原始的类加载器加载完成该类。下图展示了这种情况。</p>
<p>Systm-ClassPath classloader 加载了 MyApp.MyApp，而这个类创造了一个 java.util.Vector。假设现在 java.util.Vector 还没又被加载。因为 System-Classpath classloader 加载了 MyApp 类，它首先请求它的父亲 extension classloader 来加载这个类（java.util.Vector）。而 extension classloader 又请求 Bootstrap classloader 尝试加载。因为 java.util.Vector 是 J2SE 类，bootstrap classloader 成功加载了它。</p>
<p>考虑一个当略微不同的情况，如下图。</p>
<p>在这种情况中，MyApp 创造了一个新的用户自定义类的实例，MyClass。假设 MyClass 还没有被加载。像以往一样，当 System-Classpath classloader 接收到这个加载请求，它委托了它的父亲。最终这个委托传递到了 Bootstrap classloader。但是在 java 核心 API 里，找不到这个类。所以它的孩子加载器 Extensions classloader 尝试加载它。同样的，Extensions classloader 也没有找到它。最终，委托请求回到了 System-Classpath classloader 这里。它找到了这个类并加载成功。</p>
<h1 id="可见性原则（Visibility-principle）"><a href="#可见性原则（Visibility-principle）" class="headerlink" title="可见性原则（Visibility principle）"></a>可见性原则（Visibility principle）</h1><pre><code>被父亲类加载器加载的类对于孩子加载器是可见的，但关系相反相反则不可见。
</code></pre><p>这说明，一个类只能看见它自己的加载器或者这个加载器的父类加载器加载的类，反过来是不可以的。比如，被 ClassX 的父亲加载器加载的类是不能看见 ClassX 的。为了更清楚的理解，让我们来看一个例子，如下图。</p>
<p>图中展示了四个类加载器。类加载器 A 是最顶层的加载器，B 是它的孩子。类加载器 X 和 Y 是 B 的孩子。他们各自都加载了与自己同名的类。类加载器 A 能看见 A 类，类加载器 B 能看见 A，B 类。类似的，X 能看见 A，B，X，Y 能看见 A，B，Y。但兄弟、Y 之间的类是不可见的。</p>
<h1 id="独特性原则（Uniqueness-Principle）"><a href="#独特性原则（Uniqueness-Principle）" class="headerlink" title="独特性原则（Uniqueness Principle）"></a>独特性原则（Uniqueness Principle）</h1><pre><code>当一个类加载器加载一个类时，它的孩子加载器绝不会重新加载这个类。
</code></pre><p>这是因为委托原则中，一个加载器总是会委托自己的父亲加载器加载类。当层次中的父亲加载器无法加载类的时候，孩子类加载器就会（或者尝试去）加载这个类。这样，类加载的独特性就得到了保障。当父亲和孩子加载器加载了同一个类，一个有趣的情况就出现了。你可能会想这怎么可能出现？这不是违反了独特性原则？</p>
<p>我们用可见性原则中的示例图来解释这个问题。我们假设没有任何类被加载到这些类加载器的层次结构中。假设 X 类被类加载器 X 加载，它强制性的用类加载器 X 加载 B 类。这可以通过像 Class.Name()这样的 API 来实现，代码如下：</p>
<pre><code> public class X {

   public X() {
      ClassLoader cl = this.getClass().getClassLoader();
      Class B = Class.forName(“B”, true, cl);
   }
}
</code></pre><p>在 X 的构造函数中，B 被显示的使用类加载器 X 加载。如果另一个被类加载器 B 加载的类需要访问 B 类，则无法实现，因为委托原则只能向父亲方向查询。如果类加载器 B 也加载了 B 类，当比较两个 B 类的实例时，如果一个实例来自于类加载器 X，一个来自于类加载器 B，则会抛出 ClassCastException 异常。</p>
<p>Ref<br><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/08/classloader/" data-id="cjjgs7mij0003fgl7f7hfhaj7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Classloader/">Classloader</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-maven" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/08/maven/" class="article-date">
  <time datetime="2018-05-08T04:52:08.000Z" itemprop="datePublished">2018-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Maven/">Maven</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/08/maven/">Maven</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h1><pre><code>&lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre><p>Packaging values are: pom, jar, maven-plugin, ejb, war, ear, rar, par. This defaults to jar. The packaging type required to be pom for parent and aggregation (multi-module) projects. If the packaging is pom, the goal executed will be site:attach-descriptor. Now we may add values to the parent POM, which will be inherited by its children. </p>
<pre><code>&lt;!--在子POM中继承父POM--&gt;
&lt;parent&gt;....&lt;/parent&gt;
</code></pre><h1 id="Dependency-Management"><a href="#Dependency-Management" class="headerlink" title="Dependency Management"></a>Dependency Management</h1><p>在项目的父层，可以通过 dependencyManagement 元素来管理 jar 包的版本，让子项目中引用一个依赖而不用显示的列出版本号。  DependencyManagement configures values for child POMs and transitive dependencies. Dependency details can be set in one central location, which will propagate to all inheriting POMs. </p>
<p>父项目：</p>
<pre><code>&lt;properties&gt;
    &lt;version.framework&gt;1.0-SNAPSHOT&lt;/version.framework&gt;
    &lt;javaee-api.version&gt;1.0-SNAPSHOT&lt;/javaee-api.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;com.zhisheng&lt;/groupId&gt;
        &lt;artifactId&gt;framework-cache&lt;/artifactId&gt;
        &lt;version&gt;${version.framework}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;  
        &lt;groupId&gt;javax&lt;/groupId&gt;  
        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;  
        &lt;version&gt;${javaee-api.version}&lt;/version&gt;  
      &lt;/dependency&gt;  
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><p>子项目：</p>
<pre><code>&lt;!--引入父POM，从父POM继承大部分属性--&gt;  
&lt;parent&gt;  
    &lt;artifactId&gt;parent&lt;/artifactId&gt;  
    &lt;groupId&gt;com.zhisheng&lt;/groupId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  
    &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
&lt;/parent&gt;
&lt;!--依赖关系，不需要指定版本号--&gt;  
&lt;dependencies&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;javax&lt;/groupId&gt;  
        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;
        &lt;groupId&gt;com.zhisheng&lt;/groupId&gt;
        &lt;artifactId&gt;framework-cache&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;  
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  
        &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
&lt;/dependencies&gt;
</code></pre><p>这样做的好处：</p>
<ul>
<li>统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，才能保证测试的和发布的是相同的成果，因此，在顶层 pom 中定义共同的依赖关系。同时可以避免在每个使用的子项目中都声明一个版本号，这样想升级或者切换到另一个版本时，只需要在父类容器里更新，不需要任何一个子项目的修改；</li>
</ul>
<ul>
<li>如果某个子项目需要另外一个版本号时，只需要在 dependencies 中声明一个版本号即可。子类就会使用子类声明的版本号，覆盖父类版本号。</li>
</ul>
<h1 id="Aggregation-or-Multi-Module"><a href="#Aggregation-or-Multi-Module" class="headerlink" title="Aggregation (or Multi-Module)"></a>Aggregation (or Multi-Module)</h1><p> A pom packaged project may aggregate the build of a set of projects by listing them as modules, which are relative paths to the directories or the POM files of those projects.</p>
<pre><code>&lt;modules&gt; 
    &lt;module&gt;my-project&lt;/module&gt; 
    &lt;module&gt;another-project&lt;/module&gt; 
    &lt;module&gt;third-project/pom-example.xml&lt;/module&gt; 
&lt;/modules&gt;
</code></pre><h1 id="Inheritance-v-Aggregation"><a href="#Inheritance-v-Aggregation" class="headerlink" title="Inheritance v. Aggregation"></a>Inheritance v. Aggregation</h1><p>Inheritance and aggregation create a nice dynamic to control builds through a single, high-level POM. You will often see projects that are both parents and aggregators. For example, the entire maven core runs through a single base POM org.apache.maven:maven, so building the Maven project can be executed by a single command: mvn compile. However, although both POM projects, an aggregator project and a parent project are not one in the same and should not be confused. A POM project may be inherited from - but does not necessarily have - any modules that it aggregates. Conversely, a POM project may aggregate projects that do not inherit from it.</p>
<h1 id="import-dependencyManagement"><a href="#import-dependencyManagement" class="headerlink" title="import dependencyManagement"></a>import dependencyManagement</h1><pre><code>...
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;other.pom.group.id&lt;/groupId&gt;
            &lt;artifactId&gt;other-pom-artifact-id&lt;/artifactId&gt;
            &lt;version&gt;SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;   
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
...
</code></pre><p>What then happens is that all the dependencies defined in the dependencyManagement section of the other-pom-artifact-id are included in your POM’s dependencyManagement section. You can then reference these dependencies in the dependency section of your POM (and all of its child POMs) without having to include a version etc.</p>
<p>However if in your POM you simply define a normal dependency to other-pom-artifact-id then all dependencies from the dependency section of the other-pom-artifact-id are included transitively in your project - however the dependencies defined in the dependencyManagement section of the other-pom-artifact-id are not included at all.</p>
<p>So basically the two different mechanisms are used for importing/including the two different types of dependencies (managed dependencies and normal dependencies).</p>
<p>#####import (only available in Maven 2.0.9 or later)<br>This scope is only supported on a dependency of type pom in the <dependencymanagement> section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s <dependencymanagement> section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.</dependencymanagement></dependencymanagement></p>
<p>ref.<br><a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management" target="_blank" rel="noopener">http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/08/maven/" data-id="cjjgs7mim0005fgl71p2xltah" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Maven/">Maven</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Classloader/">Classloader</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/test/">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/A-B-Testing/">A/B Testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backpressure/">Backpressure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blue-green-Deployments/">Blue-green Deployments</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canary-Releases/">Canary Releases</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Classloader/">Classloader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-DAO-Spring-JDBC-Spring-ORM-Spring-DATA/">Spring DAO, Spring JDBC, Spring ORM, Spring DATA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/A-B-Testing/" style="font-size: 10px;">A/B Testing</a> <a href="/tags/Backpressure/" style="font-size: 10px;">Backpressure</a> <a href="/tags/Blue-green-Deployments/" style="font-size: 10px;">Blue-green Deployments</a> <a href="/tags/Canary-Releases/" style="font-size: 10px;">Canary Releases</a> <a href="/tags/Classloader/" style="font-size: 10px;">Classloader</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Spring-Cloud/" style="font-size: 10px;">Spring Cloud</a> <a href="/tags/Spring-DAO-Spring-JDBC-Spring-ORM-Spring-DATA/" style="font-size: 10px;">Spring DAO, Spring JDBC, Spring ORM, Spring DATA</a> <a href="/tags/事务/" style="font-size: 10px;">事务</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/08/springDAO/">Spring Data access</a>
          </li>
        
          <li>
            <a href="/2018/05/29/testsCategry/">Blue-green Deployments, A/B Testing, and Canary Releases</a>
          </li>
        
          <li>
            <a href="/2018/05/15/backpressure/">Backpressure</a>
          </li>
        
          <li>
            <a href="/2018/05/15/transactions/">可靠消息最终一致性</a>
          </li>
        
          <li>
            <a href="/2018/05/10/springCloud/">Spring Cloud</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>